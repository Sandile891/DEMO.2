<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Three.js Robot Simulation</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    #controls { position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.8); padding: 10px; border-radius: 5px; }
    #code { width: 300px; height: 150px; }
    #output { margin-top: 10px; height: 100px; overflow-y: auto; background: #000; color: #0f0; padding: 5px; font-family: monospace; }
  </style>
</head>
<body>
  <div id="controls">
    <textarea id="code" placeholder="Enter commands like:\nmove_forward()\nturn_left()"></textarea><br/>
    <button onclick="runCode()">Run</button>
    <div id="output"></div>
  </div>
  <canvas id="three-canvas"></canvas>

  <!-- Include Three.js and GLTFLoader -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/loaders/GLTFLoader.js"></script>
  <script>
    let scene, camera, renderer, robot, mixer;
    let wheels = {};
    let currentRotation = 0;
    let currentPosition = new THREE.Vector3(0, 0, 0);

    init();

    function init() {
      // Scene and Camera
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 5);

      // Renderer
      renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas'), antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Lighting
      const light = new THREE.HemisphereLight(0xffffff, 0x444444);
      light.position.set(0, 20, 0);
      scene.add(light);

      // Load Robot Model
      const loader = new THREE.GLTFLoader();
      loader.load('lego.glb', function(gltf) {
        robot = gltf.scene;
        scene.add(robot);

        // Identify wheels by name
        robot.traverse(function(child) {
          if (child.isMesh) {
            if (child.name === 'wheel_front_left') wheels.frontLeft = child;
            if (child.name === 'wheel_front_right') wheels.frontRight = child;
            if (child.name === 'wheel_back_left') wheels.backLeft = child;
            if (child.name === 'wheel_back_right') wheels.backRight = child;
          }
        });

        animate();
      }, undefined, function(error) {
        console.error(error);
      });

      window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    function runCode() {
      const output = document.getElementById('output');
      output.innerHTML = '';
      const code = document.getElementById('code').value;
      const lines = code.split('\n').map(line => line.trim()).filter(line => line.length > 0);

      let delay = 0;
      lines.forEach((line, index) => {
        setTimeout(() => {
          interpretCommand(line);
        }, delay);
        delay += 1000;
      });
    }

    function interpretCommand(command) {
      const output = document.getElementById('output');
      switch(command) {
        case 'move_forward()':
          output.innerHTML += 'Moving forward\n';
          moveForward();
          break;
        case 'turn_left()':
          output.innerHTML += 'Turning left\n';
          rotateRobot(-90);
          break;
        case 'turn_right()':
          output.innerHTML += 'Turning right\n';
          rotateRobot(90);
          break;
        default:
          output.innerHTML += `Unknown command: ${command}\n`;
      }
    }

    function moveForward() {
      // Move robot forward in the direction it's facing
      const angle = THREE.MathUtils.degToRad(currentRotation);
      const dx = Math.sin(angle);
      const dz = Math.cos(angle);
      currentPosition.x += dx;
      currentPosition.z += dz;
      robot.position.set(currentPosition.x, currentPosition.y, currentPosition.z);

      // Rotate wheels
      const rotationAmount = THREE.MathUtils.degToRad(360);
      for (let key in wheels) {
        wheels[key].rotation.x += rotationAmount;
      }
    }

    function rotateRobot(degrees) {
      currentRotation += degrees;
      robot.rotation.y = THREE.MathUtils.degToRad(currentRotation);
    }
  </script>
</body>
</html>
